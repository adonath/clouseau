{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"clouseau","text":"<p>Clouseau is a little tool to basically do one thing: record and inspect the forward pass of neural networks in a library independent way. It is designed to be used with PyTorch and Jax (others libraries might come later...). It helps you to debug models, transition models from one framework to another (!), and inspect the inner workings of neural networks.</p>"},{"location":"#installation","title":"Installation","text":"<p>Clouseau is available on PyPI and can be installed with:</p> <pre><code>python -m pip install clouseau\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>Let\"s start with a simple example using PyTorch:</p>"},{"location":"#pytorch-example","title":"PyTorch Example","text":"<pre><code>import torch\nfrom torch import nn\nfrom clouseau import inspector\nfrom collections import OrderedDict\n\nmodel = nn.Sequential(\n    OrderedDict([\n        (\"dense1\", nn.Linear(764, 100)),\n        (\"act1\", nn.ReLU()),\n        (\"dense2\", nn.Linear(100, 50)),\n        (\"act2\", nn.ReLU()),\n        (\"output\", nn.Linear(50, 10)),\n        (\"outact\", nn.Sigmoid()),\n    ])\n)\n\nx = torch.randn((764,))\n\nwith inspector.tail(model) as m:\n    m(x)\n</code></pre> <p>This executes the forward pass of the model and records all <code>forward</code> operations. You can then inspect the recorded arrays using:</p> <pre><code>inspector.magnify(\".clouseau/trace.safetensors\")\n</code></pre> <p>For PyTorch models the inspector registers a forward hook for each layer that matches the default filter, which is <code>isinstance(node, torch.nn.Module)</code>. It adds all array to a global cache, and finally writes the cache to a safetensors file, on exiting the context manager. After writing the file, the cache is cleared.</p>"},{"location":"#jax-example","title":"Jax Example","text":"<p><code>clouseau</code> also works with Jax. It recognizes any valid PyTree and wraps its nodes into a custom wrapper.</p> <p>Usage is exactly the same as in the example above:</p> <pre><code>import jax\nimport equinox as eqx\nfrom clouseau import inspector\nimport tempfile\nfrom pathlib import Path\n\ntmpdir = tempfile.TemporaryDirectory()\npath = Path(tmpdir.name)\n\nkeys = jax.random.split(jax.random.PRNGKey(918832), 4)\n\nmodel = eqx.nn.Sequential([\n    eqx.nn.Linear(764, 100, key=keys[0]),\n    eqx.nn.Lambda(jax.nn.relu),\n    eqx.nn.Linear(100, 50, key= keys[1]),\n    eqx.nn.Lambda(jax.nn.relu),\n    eqx.nn.Linear(50, 10, key=keys[2]),\n    eqx.nn.Lambda(jax.nn.sigmoid),\n])\nx = jax.random.normal(keys[3], (764,))\n\ndef is_leaf(path, node):\n    return isinstance(node, jax.Array) or node in (jax.nn.relu, jax.nn.sigmoid)\n\nwith inspector.tail(model, path=path / \"activations.safetensors\", is_leaf=is_leaf) as m:\n    m(x)\n</code></pre> <p>You can also provide a custom path to the <code>tail</code> function, which will be used to store the safetensors file. As the wrapper is also a PyTree node itself it can be used in any PyTree context. Thus it should also be compatible with libraries such as Equinox.</p>"},{"location":"#filtering","title":"Filtering","text":"<p>Clouseau provides a generic filtering mechanism to filter the layers you are interested in. A filter function has the following signature:</p> <pre><code>def filter_(path, node):\n    return ...\n</code></pre> <p>Now we can use the model above and e.g. only trace the output of the activation functions:</p> <pre><code>def filter_(path, node):\n    return node in (jax.nn.relu, jax.nn.sigmoid)\n\nwith inspector.tail(model, path=path / \"trace-jax-filtered.safetensors\", filter_=filter_, is_leaf=is_leaf) as m:\n    m(x)\n</code></pre> <p>Alternatively you can also filter on the content of the path, like so:</p> <pre><code>def filter_(path, node):\n    return \"act\" in path\n\nwith inspector.tail(model, path=path / \"trace-jax-filtered.safetensors\", filter_=filter_, is_leaf=is_leaf) as m:\n    m(x)\n</code></pre> <p>The path is a list of strings, while the node is the layer object. In Pytorch, this is a subclass of <code>torch.nn.Module</code>, in Jax it can be any valid node of a PyTree.</p> <p><code>clouseau</code> provide a little helper function to read from the safetensors file. This is important because safetensor files do not conserve the order of the tensors. However typically it is desired to inspect the outputs of the layers in the order they were called. As a workaround <code>clouseau</code>stores the order in the metadata and re-orders on read. For convenience there is a small wrapper the pre-serves the order on read:</p> <pre><code>from clouseau.io_utils import read_from_safetensors\n\narrays = read_from_safetensors(path / \"activations.safetensors\")\n</code></pre>"},{"location":"modules/","title":"Modules","text":"<p>Clouseau tracks the forward pass of a model and saves the intermediate arrays to a file.</p> <p>Currently it supports Jax and Pytorch models. They way this is achieved is different for both frameworks.</p> <ul> <li>For Jax it uses a wrapper class that wraps each (callable) node in the pytree ( see also https://github.com/patrick-kidger/equinox/issues/864). Saving arrays to file is a side effect in Jax. See e.g. https://docs.jax.dev/en/latest/external-callbacks.html However the global cache seems acceptable in combination with jax.experimental.io_callback, which is explicitly designed for this purpose.</li> <li>For Pytorch it uses a forward hook that is registered on each module. See e.g. https://web.stanford.edu/~nanbhas/blog/forward-hooks-pytorch/ The forward hook is de-registered after the forward pass is done.</li> </ul> <p>In both cases Jax / Pytorch it tracks the output of the layer. I might add tracking of the inputs as well later.</p>"},{"location":"modules/#clouseau.inspector.is_jax_model","title":"<code>is_jax_model(model)</code>","text":"<p>Check if model is a jax model</p> Source code in <code>clouseau/inspector.py</code> <pre><code>def is_jax_model(model: AnyModel) -&gt; bool:\n    \"\"\"Check if model is a jax model\"\"\"\n    try:\n        import jax\n\n        jax.tree.flatten(model)\n    except (ImportError, TypeError):\n        return False\n    else:\n        return True\n</code></pre>"},{"location":"modules/#clouseau.inspector.is_torch_model","title":"<code>is_torch_model(model)</code>","text":"<p>Check if model is a torch model</p> Source code in <code>clouseau/inspector.py</code> <pre><code>def is_torch_model(model: AnyModel) -&gt; bool:\n    \"\"\"Check if model is a torch model\"\"\"\n    try:\n        import torch\n\n        return isinstance(model, torch.nn.Module)\n    except ImportError:\n        return False\n</code></pre>"},{"location":"modules/#clouseau.inspector.magnify","title":"<code>magnify(filename=DEFAULT_PATH, framework='numpy', device=None)</code>","text":"<p>Visualize nested arrays using treescope</p> Source code in <code>clouseau/inspector.py</code> <pre><code>def magnify(\n    filename: str | Path = DEFAULT_PATH, framework: str = \"numpy\", device: Any = None\n) -&gt; None:\n    \"\"\"Visualize nested arrays using treescope\"\"\"\n    data = read_from_safetensors(filename, framework=framework, device=device)\n\n    print_tree(data)\n</code></pre>"},{"location":"modules/#clouseau.inspector.tail","title":"<code>tail(model, path=DEFAULT_PATH, filter_=None, is_leaf=None)</code>","text":"<p>Tail and record the forward pass of a model</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>object</code> <p>The model to inspect. Can be a PyTorch model or JAX/Equinox model.</p> required <code>path</code> <code>str or Path</code> <p>Path where to store the forward pass arrays.</p> <code>DEFAULT_PATH</code> <code>filter_</code> <code>callable</code> <p>Function that filters which tensors to inspect. Takes the pytree leaves, child modules as input and returns a boolean.</p> <code>None</code> <code>is_leaf</code> <code>callable</code> <p>Function that determines whether a node in the model tree should be treated as a leaf. Takes a node as input and returns a boolean. If True, the node will not be traversed further. This is particularly useful for JAX/Equinox models to control the granularity of inspection.</p> <code>None</code> <p>Returns:</p> Type Description <code>_Inspector</code> <p>Inspector instance that can be used as a context manager.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from clouseau import inspector, magnifier\n&gt;&gt;&gt; model = torch.nn.Linear(10, 5)\n&gt;&gt;&gt; with inspector.tail(model,  path=\".clouseau/trace-torch.safetensors\") as fmodel:\n...     out = fmodel(torch.randn(3, 10))\n</code></pre> <p>When working with a JAX/Equinox model, it is important to add <code>.block_until_ready()</code></p> <pre><code>&gt;&gt;&gt; import jax\n&gt;&gt;&gt; with inspector.tail(model, path=\".clouseau/trace-jax.safetensors\") as fmodel:\n...     fmodel(x, time).block_until_ready()\n</code></pre> Source code in <code>clouseau/inspector.py</code> <pre><code>def tail(\n    model: AnyModel,\n    path: str | Path = DEFAULT_PATH,\n    filter_: Callable[[Any, Any], bool] | None = None,\n    is_leaf: Callable[[Any, Any], bool] | None = None,\n) -&gt; _Recorder:\n    \"\"\"Tail and record the forward pass of a model\n\n    Parameters\n    ----------\n    model : object\n        The model to inspect. Can be a PyTorch model or JAX/Equinox model.\n    path : str or Path\n        Path where to store the forward pass arrays.\n    filter_ : callable\n        Function that filters which tensors to inspect.\n        Takes the pytree leaves, child modules as input and returns a boolean.\n    is_leaf : callable, optional\n        Function that determines whether a node in the model tree should be treated as a leaf.\n        Takes a node as input and returns a boolean. If True, the node will not be traversed further.\n        This is particularly useful for JAX/Equinox models to control the granularity of inspection.\n\n    Returns\n    -------\n    _Inspector\n        Inspector instance that can be used as a context manager.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import torch\n    &gt;&gt;&gt; from clouseau import inspector, magnifier\n    &gt;&gt;&gt; model = torch.nn.Linear(10, 5)\n    &gt;&gt;&gt; with inspector.tail(model,  path=\".clouseau/trace-torch.safetensors\") as fmodel:\n    ...     out = fmodel(torch.randn(3, 10))\n\n    When working with a JAX/Equinox model, it is important to add `.block_until_ready()`\n    &gt;&gt;&gt; import jax\n    &gt;&gt;&gt; with inspector.tail(model, path=\".clouseau/trace-jax.safetensors\") as fmodel:\n    ...     fmodel(x, time).block_until_ready()\n\n    \"\"\"\n    return _Recorder(model=model, path=path, filter_=filter_, is_leaf=is_leaf)\n</code></pre>"}]}